# -*- coding: utf-8 -*-
import json
from datetime import datetime
from pathlib import Path
from ZIPUtility import ZIPUtility
from ZIPHelper import ZIPHelper
from data_manager.MemoryManager import MemoryManager

class ZIPConvertor:
    def __init__(self, base_dir: Path, output_dir: Path):
        self.base_dir = Path(base_dir)
        self.output_dir = Path(output_dir)
        ZIPUtility.ensure_dir(self.output_dir)

    def generate_defaults(self, text: str, fmt: str, segments: list[str]):

        (self.base_dir / "transcript.txt").write_text(text or "", encoding="utf-8")


        chapters = [{"id": i+1, "file": seg, "title": f"Chapter {i+1}"} for i, seg in enumerate(segments)]
        (self.base_dir / "chapters.json").write_text(json.dumps(chapters, indent=2), encoding="utf-8")


        config = {
            "format": fmt,
            "createdAt": datetime.now().isoformat(),
            "service": MemoryManager.get("tts_service", "unknown"),
            "lang": MemoryManager.get("tts_lang", "en"),
            "voice": MemoryManager.get("tts_voice", "female"),
            "effects": {
                "speed": MemoryManager.get("speed", 1.0),
                "pitch": MemoryManager.get("pitch", 0),
                "volume": MemoryManager.get("volume", 1.0),
                "echo": MemoryManager.get("echo", False),
                "reverb": MemoryManager.get("reverb", False),
                "robot": MemoryManager.get("robot", False),
            }
        }
        (self.base_dir / "config.json").write_text(json.dumps(config, indent=2), encoding="utf-8")


        project = {
            "name": "Zero to Dev - Developer GUI",
            "author": "Tuna Rasim OCAK",
            "version": "1.0",
            "createdAt": datetime.now().isoformat()
        }
        (self.base_dir / "project.json").write_text(json.dumps(project, indent=2), encoding="utf-8")


        metadata = {
            "segments": len(segments),
            "format": fmt,
            "transcriptLength": len(text),
            "zip_enabled": MemoryManager.get("zip_export_enabled", False),
            "log_mode": MemoryManager.get("log_mode", "INFO")
        }
        (self.base_dir / "metadata.json").write_text(json.dumps(metadata, indent=2), encoding="utf-8")


        events = [{
            "event": "convert",
            "time": datetime.now().isoformat(),
            "service": config["service"],
            "format": fmt,
            "lang": config["lang"]
        }]
        (self.base_dir / "events.json").write_text(json.dumps(events, indent=2), encoding="utf-8")

        readme = (
            "This package was generated by TTS Exporter.\n\n"
            "Files:\n"
            "- transcript.txt : Full transcript of the text\n"
            "- chapters.json : Chapters list\n"
            "- config.json : Conversion settings (from MemoryManager)\n"
            "- project.json : Project info (name, author, version)\n"
            "- metadata.json : Technical metadata\n"
            "- events.json : Processing events\n"
            "- preview.xxx : Short preview audio\n"
            "- segments/ : Folder containing chapter audios\n"
        )
        (self.base_dir / "readme.txt").write_text(readme, encoding="utf-8")

    def export(self, text: str, fmt: str, zip_name: str = "tts_package.zip") -> Path:
        segments_dir = self.base_dir / "segments"
        segment_files = ZIPUtility.list_segment_files(segments_dir, fmt)


        self.generate_defaults(text, fmt, [f.name for f in segment_files])

        files = {
            "transcript.txt": self.base_dir / "transcript.txt",
            "chapters.json": self.base_dir / "chapters.json",
            "config.json": self.base_dir / "config.json",
            "project.json": self.base_dir / "project.json",
            "metadata.json": self.base_dir / "metadata.json",
            "events.json": self.base_dir / "events.json",
            "readme.txt": self.base_dir / "readme.txt",
            f"preview.{fmt}": self.base_dir / f"preview.{fmt}",
        }

        output_path = self.output_dir / ZIPUtility.normalize_name(zip_name)
        return ZIPHelper.create_zip(output_path, files, segment_files)
